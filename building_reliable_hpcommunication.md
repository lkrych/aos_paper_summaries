# Building reliable, high-performance communication systems from components

### Authors: Xiaoming Liu, Christoph Kreitz, Robbert van Renesse, Jason Hickey, Mark Hayden, Kenneth Birman, Robert Constable from the Department of Computer Science, Cornell University

#### Published: Operating Systems Review, 34(5):80â€“92, Dec. 1999

## Table of Contents

* [Introduction](#introduction)
* [What is Ensemble?](#what-is-ensemble?)
* [Formalization](#formalization)
* [How does it work?](#how-does-it-work?)
* [Experimental Setup](#experimental-setup)
* [Results](#results)
* [Conclusion](#conclusion)
* [Sources](#sources)

### Introduction

The beauty of a correct mathematical proof is that it is true and forever true. It is as if world peace has been achieved and we will forever be welcomed back to Eden. Alas, if only reality could be as beautiful as mathematics. While world peace is probably a pipe dream, instituting the rigor of mathematical proofs in the real world is slowly becoming more and more feasible. In the paper `Building reliable, high-performance communication systems from components`, researchers from Cornell University describe how the Ensemble protocols can be optimized and hardened using formal methods.

### What is Ensemble?

"Ensemble is a high-performance network protocol architecture, designed primarily to support group membership and communication protocols."[1] Ensemble is written in OCaml, a statically-typed general-purpose programming language. It is organized into modules which can be stacked on top of each other as layers. Each module communicates with the module above or below it. Each module adheres to a common event-driven interface.


### Formalization

Every design decision comes with trade-offs. Crafting systems out of components can make individual components of systems "easier to design, develop, test and optimize." Unfortunately, the abstraction barriers between components can impose high overhead.[1] One of the goals of this paper is to use automated formalization techniques to improve the efficiency of the Ensemble system as well as harden the code by using formal verification techniques.   

The strategy taken by the authors is to translate the Ensemble modules into representations that can be easily used by the automated formal reasoning system **Nuprl**. The authors use tools to convert Ensemble OCaml code into the corresponding structures of Nuprl's input language and vice-versa. This translation is the secret sauce of the paper and is what enables the authors to utilize formal verification and optimization techniques.  

To get the Nuprl system work, the researchers needed two forms of input. The first input that they use is I/O automata to specify the behavior of the modules they are working with. They then combine this representation with the OCaml implementation  of the module in the Nuprl system to verify and optimize the code. 

### How does it work?

Once Nuprl has been given the proper input, how does it do its magic?

The system uses two levels of analysis. The first is the static level, which depends solely on the module implementation being fed to the system. To do this, an Ensemble programmer loads the OCaml module that they've developed into Nuprl. Nuprl converts this code into the Nuprl logical language. It then analyzes and simplifies the module to conform to a **Common Case Predicate (CCP)**, a high-level description of the interface between the upper and lower layers of a module. Checking this conformity assures that the optimized code is correct.

The second form of optimization performed by Nuprl is dynamic optimization. This optimization is concerned with the runtime context of the module that needs to be optimized. It takes a look at all the layers of the protocol and composes the *a priori* static optimizations into a system that conforms to the original semantic design.

### Experimental Setup

The experiments of this paper were run on two UltraSparc stations running Solaris 2.6 and connected by a 100Mbit Ethernet connection. Each test was run 10,000 times and latency measurements were taken using Solaris' `gettimeofday` function.

Two different ensemble stacks were chosen for measurement, the first stack uses 10 protocol layers and provides flow control, total order and fragmentation/reassembly. The second stack is a 4-layer stack. Each stack was prepared in one of four ways:

1. **Imperative** - the normal version of the stack. It uses a scheduler to coordinate message passing. Can be thought of as a control.
2. **Functional** - Does not use a scheduler, but instead composes the layers into functional relationships that pass inputs and outputs into subsequent layers.
3. **Hand-optimized** - Utilizes common bypass methods that can be inserted by hand to speed up the communication. Note, this was not used in the ten-layer Ensemble stack.
4. **Machine-optimized** - Generated by passing the functional code into the Nuprl system.

### Results

In both sets of experiments the machine-optimized code exhibited lower latencies than the imperative and functional code bases. One surprising result is that in the 4-layer ensemble stack, the hand-optimized code was faster than the machine-optimized code. The authors attribute this to the bypass method that was used to avoid the protocol stack and Transport module. Regardless of this finding, the machine-optimized code worked better in both situations than the imperative code, the out-of-the-box offering. 

### Conclusion

Automated optimization and verification tools promise to improve the efficiency and reliability of numerous computer systems. That being said, there were many steps in the paper that required expert human intervention to utilize the automation tools. This underscores the fact that experts who understand the context of the systems that are being optimized are critical for successful use of these advanced tools. Nevertheless, the results point to a future of efficient, reliable computer systems, and while it is not world peace, it'll do.

### Sources

1. Liu, X., Kreitz, C., Renesse, R. V., Hickey, J., Hayden, M., Birman, K., &amp; Constable, R. (1999). Building reliable, high-performance communication systems from components. Proceedings of the Seventeenth ACM Symposium on Operating Systems Principles - SOSP '99. doi:10.1145/319151.319157